# YokeFlow Parallel Execution Enhancement - Self-Improvement Specification

## Project Overview

Enhance YokeFlow with parallel task execution, self-learning capabilities, and intelligent orchestration. This upgrade enables 3-5x speedup through concurrent task execution, persistent domain expertise, and cost-optimized model selection.

**Tech Stack:**
- Python 3.11+ (existing)
- PostgreSQL 14+ (existing)
- TypeScript/Node.js for MCP server (existing)
- FastAPI + Next.js (existing)
- Claude Agent SDK (existing)

**This is a self-enhancement project:** YokeFlow building its own improvements.

---

## Architecture Vision

```
SESSION 0: PLANNING
├── Read app_spec.txt
├── Generate epics/tasks WITH DEPENDENCIES
├── Build dependency graph (Kahn's algorithm)
└── Compute parallel batches

PARALLEL EXECUTION ENGINE
├── For each batch (sequential across batches):
│   ├── Create git worktrees per epic (isolation)
│   ├── Spawn parallel agents (max_concurrency limit)
│   ├── Each agent reads domain expertise
│   ├── Execute tasks in isolated worktrees
│   └── Merge to main when batch complete
│
│   SELF-LEARNING LAYER
│   ├── Expertise files persist domain knowledge
│   ├── Cost tracker informs model selection
│   └── Feedback loop: Session N learns from N-1
│
└── Continue until all batches complete
```

---

## Epic 00: Core Refinements (Quick Wins)

**Priority:** P0 | **Dependencies:** None | **Phase:** 0

Improvements from real-world usage (PodPal project push experience).

### Tasks

**0.1 Standard .gitignore Template**
- Modify `prompts/initializer_prompt_local.md` and `prompts/initializer_prompt_docker.md`
- Add comprehensive .gitignore instructions BEFORE any dependency installation
- Include: node_modules/, venv/, .venv/, __pycache__/, .env, dist/, build/, coverage/
- Ensure .gitignore is committed BEFORE running init.sh

**0.2 init.sh .gitignore Guard**
- Modify init.sh generation to check for .gitignore existence
- Create default .gitignore if missing before installing dependencies
- Commit .gitignore before npm install / pip install

**0.3 Post-Session Validation**
- Create `core/validation.py`
- Implement `validate_repository()` - detect committed venv/node_modules
- Implement `fix_gitignore()` - auto-add missing exclusions
- Integrate into session completion flow

**0.4 Documentation: Exporting Projects**
- Create `docs/exporting-projects.md`
- Document how to push generated projects to their own repos
- Include troubleshooting for large repository issues
- Provide cleanup commands for accidentally committed dependencies

**0.5 Coding Prompt .gitignore Reminder**
- Modify `prompts/coding_prompt.md`
- Add pre-commit checklist for .gitignore verification
- Include commands to fix if dependencies were staged

---

## Epic 01: Foundation Infrastructure

**Priority:** P0 | **Dependencies:** None | **Phase:** 1

### Tasks

**1.1 Database Schema Extensions**
- Create `schema/postgresql/parallel_execution.sql`
- Add to tasks table: `depends_on INTEGER[] DEFAULT '{}'`, `dependency_type VARCHAR(20) DEFAULT 'hard'`
- Add to epics table: `depends_on INTEGER[] DEFAULT '{}'`
- Create `parallel_batches` table (id, project_id, batch_number, status, task_ids[], timestamps)
- Create `worktrees` table (id, project_id, epic_id, branch_name, worktree_path, status, merge_commit)
- Create `agent_costs` table (id, project_id, session_id, task_id, model, tokens, cost_usd)
- Create `expertise_files` table (id, project_id, domain, content JSONB, version, line_count)
- Create `expertise_updates` table (id, expertise_id, session_id, change_type, summary, diff)

**1.2 Database Views**
- Create `v_project_costs` view (cost aggregation by model and operation)
- Create `v_parallel_progress` view (batch status with task counts)
- Create `v_worktree_status` view (worktree status with epic info)

**1.3 Database Abstraction Layer Updates**
- Add to `core/database.py`:
  - Parallel batch CRUD: create_parallel_batch, get_parallel_batch, list_parallel_batches, update_batch_status
  - Worktree CRUD: create_worktree, get_worktree, get_worktree_by_epic, list_worktrees, mark_worktree_merged
  - Cost tracking: record_agent_cost, get_project_costs, get_cost_by_model
  - Expertise CRUD: get_expertise, save_expertise, list_expertise_domains, record_expertise_update
  - Dependencies: get_task_dependencies, set_task_dependencies, get_tasks_with_dependencies

**1.4 Configuration Schema Updates**
- Update `core/config.py` with new config classes
- Add parallel config: enabled, max_concurrency, strategy, worktree_dir, merge_strategy
- Add learning config: enabled, expertise_max_lines, self_improve_interval, domains
- Add cost config: budget_limit_usd, optimization_enabled, default_model, model_overrides

**1.5 Core Module Structure**
- Create `core/parallel/__init__.py`
- Create `core/parallel/dependency_resolver.py` (stub)
- Create `core/parallel/worktree_manager.py` (stub)
- Create `core/parallel/parallel_executor.py` (stub)
- Create `core/learning/__init__.py`
- Create `core/learning/expertise_manager.py` (stub)
- Create `core/learning/model_selector.py` (stub)

**1.6 MCP Transaction Utilities (CRITICAL)**
- Modify `mcp-task-manager/src/database.ts`
- Add transaction wrapper with BEGIN/COMMIT/ROLLBACK
- Add `updateTaskStatusSafe()` with row-level locking (FOR UPDATE)
- Ensure epic completion check is atomic
- This is REQUIRED before parallel execution can work safely

---

## Epic 02: Dependency Resolution System

**Priority:** P0 | **Dependencies:** Epic 01 | **Phase:** 1

### Tasks

**2.1 DependencyResolver Core Implementation**
- Implement `core/parallel/dependency_resolver.py`
- Create DependencyGraph dataclass (batches, task_order, circular_deps, missing_deps)
- Implement Kahn's algorithm for topological sorting
- Handle task dependencies and epic dependencies
- Priority ordering within batches

**2.2 Dependency Visualization**
- Add `to_mermaid()` method - generate Mermaid diagram
- Add `to_ascii()` method - CLI representation
- Add `get_critical_path()` - identify longest dependency chain

**2.3 Session 0 Dependency Prompt Integration**
- Modify initializer prompts to request dependency declarations
- Add instructions for depends_on format
- Document common dependency patterns (schema before API, API before UI)

**2.4 Dependency Parsing**
- Create `core/parallel/dependency_parser.py`
- Parse explicit dependency declarations from task JSON
- Implement inference heuristics from descriptions
- Validate parsed dependencies

**2.5 MCP Tool Updates**
- Update `create_task` tool to accept depends_on and dependency_type
- Add `get_dependency_graph` tool (json, mermaid, ascii formats)
- Add `get_parallel_batches` tool

**2.6 API Endpoints**
- GET /api/projects/{id}/dependencies - full graph
- GET /api/projects/{id}/dependencies/batches - parallel batches
- GET /api/projects/{id}/dependencies/critical-path
- POST /api/projects/{id}/tasks/{task_id}/dependencies
- GET /api/projects/{id}/dependencies/validate

---

## Epic 03: Git Worktree Isolation

**Priority:** P0 | **Dependencies:** Epic 01 | **Phase:** 1

### Tasks

**3.1 WorktreeManager Core Implementation**
- Implement `core/parallel/worktree_manager.py`
- Create WorktreeInfo dataclass (path, branch, epic_id, status, timestamps)
- Implement initialize(), create_worktree(), merge_worktree(), cleanup_worktree()
- Implement get_worktree_status(), list_worktrees(), sync_worktree_from_main()

**3.2 Git Command Execution**
- Implement async _run_git() with timeout handling
- Create GitCommandError and WorktreeConflictError exceptions
- Implement _get_main_branch(), _get_current_branch(), _has_uncommitted_changes()

**3.3 Worktree Creation Flow**
- Check for existing worktree (reuse if valid)
- Create .worktrees directory
- Create branch from main
- Create worktree linked to branch
- Record in database

**3.4 Worktree Merge Flow**
- Commit uncommitted changes
- Check for potential conflicts
- Perform merge (regular or squash)
- Handle conflicts with abort
- Update database status

**3.5 Conflict Resolution**
- Implement _check_merge_conflicts() - dry run detection
- Implement get_conflict_details() - conflicting files list
- Implement resolve_conflict() - ours/theirs/manual strategies

**3.6 Database Integration**
- Sync in-memory state with database
- Recover state on restart
- Track merge commits

**3.7 API Endpoints**
- GET /api/projects/{id}/worktrees
- GET /api/projects/{id}/worktrees/{epic_id}
- POST /api/projects/{id}/worktrees/{epic_id}/merge
- GET /api/projects/{id}/worktrees/{epic_id}/conflicts
- POST /api/projects/{id}/worktrees/{epic_id}/resolve
- DELETE /api/projects/{id}/worktrees/{epic_id}

**3.8 Windows Path Sanitization**
- Implement _sanitize_branch_name() with Windows compatibility
- Handle reserved names (CON, PRN, AUX, NUL, COM1-9, LPT1-9)
- Remove invalid characters (: * ? " < > |)
- Handle trailing dots, max path length (200 chars)

**3.9 Pre-Merge Conflict Detection**
- Use git merge-tree for detection without modifying tree
- Return list of conflicting files
- Provide resolution recommendations

---

## Epic 04: Parallel Execution Engine

**Priority:** P0 | **Dependencies:** Epic 01, Epic 02, Epic 03 | **Phase:** 2

### Tasks

**4.1 ParallelExecutor Core Implementation**
- Implement `core/parallel/parallel_executor.py`
- Create ExecutionResult dataclass
- Create RunningAgent dataclass
- Initialize with project_path, project_id, max_concurrency, progress_callback

**4.2 Batch Execution Flow**
- Load and filter incomplete tasks
- Resolve dependencies into batches
- Create batch records in database
- Initialize worktree manager
- Process batches sequentially, tasks within batch in parallel

**4.3 Concurrent Task Execution**
- Implement execute_batch() with semaphore-based concurrency
- Group tasks by epic for worktree assignment
- Create worktrees for each epic in batch
- Use asyncio.gather() with return_exceptions=True
- Merge successful worktrees after batch

**4.4 Individual Task Agent Execution**
- Implement run_task_agent()
- Load expertise for task domain
- Select optimal model
- Build context-rich prompt
- Track running agent
- Create session, run agent, update status
- Record cost and learn from result

**4.5 Agent Session Execution**
- Implement _execute_agent_session()
- Create client pointing to worktree
- Run agent session with session logger
- Capture metrics, update session in database

**4.6 Task Prompt Builder**
- Build prompts with task details, expertise, guidelines
- Explain worktree context
- Include verification instructions

**4.7 Cancellation and Status**
- Implement cancel() - set cancel event for all agents
- Implement get_status() - running agents, active count, duration

**4.8 Orchestrator Integration**
- Add parallel and max_concurrency parameters to start_coding_sessions()
- Route to ParallelExecutor when parallel=True
- Maintain backward compatibility

**4.9 API Endpoints**
- POST /api/projects/{id}/parallel/start
- GET /api/projects/{id}/parallel/status
- POST /api/projects/{id}/parallel/cancel
- GET /api/projects/{id}/parallel/batches
- GET /api/projects/{id}/parallel/batches/{batch_num}

**4.10 CLI Integration**
- Add --parallel flag
- Add --max-concurrency option (default: 3)

---

## Epic 05: Self-Learning System

**Priority:** P1 | **Dependencies:** Epic 01, Epic 04 | **Phase:** 3

### Tasks

**5.1 ExpertiseManager Core Implementation**
- Implement `core/learning/expertise_manager.py`
- Define DOMAINS: database, api, frontend, testing, security, deployment, general
- Define MAX_EXPERTISE_LINES = 1000
- Create ExpertiseFile dataclass

**5.2 Domain Classification**
- Implement classify_domain() with keyword scoring
- Define DOMAIN_KEYWORDS for each domain
- Check file paths for additional signals
- Fall back to 'general' when uncertain

**5.3 Learning Extraction**
- Implement learn_from_session()
- Extract learnings from failures (error messages, solutions)
- Extract effective tool patterns from logs
- Track modified files
- Record successful techniques

**5.4 Tool Pattern Extraction**
- Implement _extract_tool_patterns()
- Detect Read -> Edit -> Test patterns
- Capture successful tool combinations
- Implement _extract_modified_files()

**5.5 Expertise Validation**
- Implement validate_expertise()
- Verify core files exist
- Prune stale failure learnings (>30 days)
- Update validation timestamp
- Implement self_improve() - scan codebase for relevant files

**5.6 Prompt Formatting**
- Implement _format_for_prompt()
- Format expertise as readable markdown
- Limit content to avoid token bloat
- Prioritize recent/relevant information

**5.7 Line Limit Enforcement**
- Implement _enforce_line_limit()
- Prune old failure learnings
- Trim old patterns and techniques
- Limit core files list

**5.8 Database Integration**
- Store expertise in database with versioning
- Record update history for audit trail
- Support dual storage (file + database)

**5.9 API Endpoints**
- GET /api/projects/{id}/expertise
- GET /api/projects/{id}/expertise/{domain}
- POST /api/projects/{id}/expertise/{domain}/validate
- POST /api/projects/{id}/expertise/{domain}/improve
- GET /api/projects/{id}/expertise/{domain}/history

---

## Epic 06: Cost Optimization & Model Selection

**Priority:** P1 | **Dependencies:** Epic 01, Epic 05 | **Phase:** 3

### Tasks

**6.1 ModelSelector Core Implementation**
- Implement `core/learning/model_selector.py`
- Define ModelTier enum (HAIKU, SONNET, OPUS)
- Create ModelRecommendation and TaskComplexity dataclasses
- Define PRICING and COMPLEXITY_THRESHOLDS

**6.2 Task Complexity Analysis**
- Implement analyze_complexity()
- Score reasoning_depth, code_complexity, domain_specificity, context_requirements
- Calculate weighted overall_score

**6.3 Historical Performance Learning**
- Implement record_outcome()
- Track success/fail rates per model per task type
- Cache performance data
- Sync with database

**6.4 Budget Management**
- Implement check_budget()
- Track spent_usd vs budget_limit
- Downgrade model when approaching limit
- Provide warnings

**6.5 Configuration Overrides**
- Support model_overrides by task type
- Support priority_overrides by epic priority
- Apply overrides before complexity-based selection

**6.6 Cost Tracking API**
- GET /api/projects/{id}/costs - breakdown by model and task type
- GET /api/projects/{id}/costs/forecast - remaining cost estimate
- GET /api/projects/{id}/model-stats - model performance statistics

---

## Epic 07: Observability & UI

**Priority:** P1 | **Dependencies:** Epic 01, Epic 04 | **Phase:** 3

### Tasks

**7.1 Swimlane Visualization Component**
- Create React component for parallel task visualization
- Column per epic, row per task
- Real-time status coloring (pending, running, complete, error)
- Dependency arrows between related tasks

**7.2 Progress Dashboard**
- Batch progress bar
- Running agents list with status
- Cost accumulator display
- ETA based on historical data

**7.3 WebSocket Events**
- Emit batch_start, batch_complete events
- Emit task_start, task_complete events
- Emit cost_update events
- Emit agent_status events

**7.4 Expertise Viewer**
- UI for viewing expertise files by domain
- Show validation status
- Display learning history
- Allow manual editing

**7.5 Cost Dashboard**
- Real-time cost tracking
- Budget usage visualization
- Model usage breakdown
- Cost trend charts

---

## Epic 08: Testing & Documentation

**Priority:** P1 | **Dependencies:** Epic 01-07 | **Phase:** 4

### Tasks

**8.1 Unit Tests - Dependency Resolution**
- Test no dependencies (single batch)
- Test linear dependencies (sequential batches)
- Test parallel branches
- Test circular dependency detection
- Test missing dependency handling

**8.2 Unit Tests - Worktree Manager**
- Test create/merge/cleanup worktrees
- Test conflict detection
- Test branch name sanitization
- Test database sync

**8.3 Unit Tests - Parallel Executor**
- Test single batch execution
- Test multi-batch execution
- Test concurrency limits
- Test failure handling
- Test cancellation

**8.4 Unit Tests - Self-Learning**
- Test domain classification
- Test learning extraction
- Test line limit enforcement
- Test validation

**8.5 Unit Tests - Cost Optimization**
- Test complexity scoring
- Test model selection
- Test budget enforcement
- Test configuration overrides

**8.6 Integration Tests**
- Test end-to-end parallel execution
- Test worktree merge workflow
- Test expertise accumulation
- Test cost tracking accuracy

**8.7 Documentation**
- Update README with parallel execution
- Document configuration options
- Create migration guide from sequential
- Document API endpoints
- Create troubleshooting guide

---

## Implementation Requirements

### Testing Strategy

All features must be verified:
1. Unit tests for each module
2. Integration tests for workflows
3. Manual testing in development mode

### Verification Steps

1. **Dependency Resolution**
   - Create tasks with dependencies
   - Verify correct batch computation
   - Test circular dependency detection

2. **Worktree Isolation**
   - Create multiple worktrees
   - Make changes in parallel
   - Merge without conflicts

3. **Parallel Execution**
   - Run with --parallel flag
   - Verify concurrent agent execution
   - Check batch ordering

4. **Self-Learning**
   - Run multiple sessions
   - Verify expertise accumulates
   - Check validation prunes stale data

5. **Cost Optimization**
   - Track costs across sessions
   - Verify model selection logic
   - Test budget enforcement

---

## Success Criteria

Project is complete when:

1. Database schema extended with all new tables
2. MCP transaction safety implemented (CRITICAL)
3. Dependency resolver computes correct batches
4. Worktree manager creates/merges/cleans up worktrees
5. Parallel executor runs multiple agents concurrently
6. Self-learning system accumulates domain expertise
7. Cost optimization selects appropriate models
8. UI shows parallel execution progress
9. All unit tests pass
10. Integration tests pass
11. Documentation updated

---

## Quality Standards

### Code Quality
- Clean, readable async Python code
- Proper error handling
- Type hints throughout
- Docstrings for public methods
- No circular imports

### Database
- Idempotent schema changes
- Proper indexes for common queries
- Transaction safety for concurrent operations

### Testing
- >80% test coverage for new code
- All edge cases tested
- Performance tests for concurrency

---

## Notes for Agent

### Critical Prerequisites
- Task 1.6 (MCP Transaction Utilities) MUST be completed before Epic 04
- Without transaction safety, concurrent agents will corrupt data

### Research Findings
- SDK has NO barriers to parallel execution (each query() spawns subprocess)
- ADWS learning system has gaps - our design is MORE robust (1000-line cap, deduplication)
- Automaker patterns should be used for Windows path sanitization

### Self-Enhancement Context
- This project enhances YokeFlow itself
- Expertise files for YokeFlow's own patterns will accumulate
- Future enhancements benefit from learned expertise

### Safety
- Use worktree isolation to protect running YokeFlow instance
- Test changes in worktree before merging to main
- Keep parallel mode as opt-in initially
